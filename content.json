{"meta":{"title":"魍魉","subtitle":"坏人","description":"blog","author":"Yang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-09-14T03:21:19.000Z","updated":"2019-09-14T03:23:00.803Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM","slug":"JVM","date":"2022-07-24T11:04:29.416Z","updated":"2022-07-25T07:36:53.825Z","comments":true,"path":"2022/07/24/JVM/","link":"","permalink":"http://yoursite.com/2022/07/24/JVM/","excerpt":"","text":"JVM是Java Virtual Machine的缩写。它是一种基于计算设备的规范，是一台虚拟机，即虚构的计算机。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 java文件编译执行过程java文件(.java) –javac编译–&gt; 字节码文件(.class) –类加载器(classloader)–&gt; JVM解释执行 类加载器 启动类加载器 Bootstarp ClassLoader 扩展类加载器 ExtClassLoader 应用类加载器 AppClassLoader 自定义类加载器 User ClassLoader 双亲委派机制：当类加载器收到加载类的请求时，会先提交给父加载器，父加载器继续向其父加载器传递，最终传到顶层启动类加载器。若父加载器能加载该类，则成功返回，否则才由子加载器加载。 JVM运行时数据区 方法区(method area) 又称非堆(non-heap)，所有线程的共享内存，存储已被Java虚拟机加载的类信息(构造方法、接口定义)、常量(final)、静态变量(static)、即时编译器编译后的代码等数据。 注：方法区是堆上的一个概念，具体的落地实现是永久代(PermGen)或者元空间(MetaSpace)，它们都统称方法区。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。 堆(heap) 最大的一块内存空间，主要用于存放对象实例。堆内存又分为： 新生区 伊甸园区(刚new出来的对象实例都在伊甸园区) 幸存0区、幸存1区(0区与1区动态轮换，当新建的对象多次轮换后会移动到老年区，默认经历15次GC) 老年区 永久区/元空间(常驻内存。用来存放JDK自带的Class对象，interface元数据，存储的是java运行时的一些环境。这个区域不存在垃圾回收) 注：PermGen space是JDK7及之前，HotSpot虚拟机对方法区的一个落地实现，在JDK8被移除。 Metaspace(元空间)是JDK8及之后，HotSpot虚拟机对方法区的新的实现。 GC垃圾回收主要在伊甸园区和老年区。 栈(stack) 线程的私有内存，生命周期与线程相同，用于存放局部变量表、操作数栈、动态链接、方法出口等信息(8种基本数据类型+对象引用+实例的方法)。栈运行的原理：栈帧(stackframe) 程序计数器(program counter) 一块较小的内存空间，用于保存当前线程所正在执行的字节码指令的地址(行号)。 本地方法栈(native method stack) native关键字修饰的方法，存放的一般是C、C++代码 内存溢出(OOM) 扩大堆内存看结果 -Xms1024m -Xmx1024m -XX:+PrintGCDetails 命令行作用:设置堆可占用最大内存为1024MB，堆的初始化内存为1024MB，打印垃圾回收器GC相关信息 分析内存，找出问题(内存快照分析工具MAT、Jprofile) GC垃圾回收JVM在进行GC时，大部分时间都是在新生区。 GC种类： 轻GC(Young GC)：普通的GC 重GC(Full GC)：全局的GC GC算法： 引用计数法 给每个对象设置一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；计数器的值为0的对象就是不可能再被使用的。 该方法在Java中并未被使用，python中有使用。优点：可即时回收垃圾。缺点：实现繁琐，且计数器也要消耗一定内存。 标记-清除法 分为标记和清除两个阶段。标记就是把所有存活对象都做上标记的阶段；清除就是将没有做上标记的对象进行回收的阶段。优点：实现简单，不需要额外空间。缺点：两次扫描浪费时间，内存碎片化。 标记-压缩法 与标记-清除类似，防止内存碎片产生，扫描过程中把存活的对象移动到一端。优点：可以有效的利用堆。缺点：压缩需要花比较多的时间成本。 复制算法 复制算法就是将内存空间按容量分成两块。当一块内存用完的时候，就将还存活着的对象复制到另外一块上面，然后把已经使用过的这一块内存一次清理掉。 最佳使用场景：对象存活度较低的时候，及新生区。优点：吞吐量大，内存不会碎片化。缺点：浪费一半的空间，堆内存使用效率低。 垃圾回收机的实现不是仅仅用哪一种回收算法，而是将几个结合使用，即分代收集算法(年轻代存活率低，复制算法；老年区存活率高，区域大，标记-清除法(内存碎片少)和标记-压缩法混合使用)。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}],"keywords":[]},{"title":"排序算法","slug":"排序算法","date":"2022-07-23T13:34:42.000Z","updated":"2022-07-23T13:34:42.451Z","comments":true,"path":"2022/07/23/排序算法/","link":"","permalink":"http://yoursite.com/2022/07/23/排序算法/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Regex","slug":"Regex","date":"2022-07-16T10:29:04.000Z","updated":"2022-07-23T13:30:45.365Z","comments":true,"path":"2022/07/16/Regex/","link":"","permalink":"http://yoursite.com/2022/07/16/Regex/","excerpt":"","text":"常用正则表达式字符 基本语法元字符 元字符 说明 . 除换行符以外的任意字符 \\w 字母、数字、下划线、汉字 \\s 任意空白符(换行符\\n、回车符\\r、制表符\\t等) \\d 数字(0-9) \\D \\d的补集(除0-9外的字符)，等价[^0-9] \\W \\w的补集 \\S \\s的补集 定位符 元字符 说明 ^ 字符串的开始 $ 字符串的结束 \\b 单词的开始或结束 重复描述符 元字符 说明 ？ 零次或一次 + 重复一次次或更多次 * 重复零次或更多次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n次到m次 特殊符 元字符 说明 \\ 转义字符 | 条件逻辑或 () 分组 [] 区间","categories":[],"tags":[{"name":"regex","slug":"regex","permalink":"http://yoursite.com/tags/regex/"}],"keywords":[]},{"title":"Java反射","slug":"Java反射","date":"2022-07-15T08:56:39.000Z","updated":"2022-07-23T13:24:33.670Z","comments":true,"path":"2022/07/15/Java反射/","link":"","permalink":"http://yoursite.com/2022/07/15/Java反射/","excerpt":"","text":"反射指程序可以访问、检测和修改它本身状态或行为的能力。通过反射，可以动态获取对象信息以及动态调用对象的方法。 反射机制主要功能 运行是检测对象类型 动态创建对象 检索对象属性和方法 调用对象方法 修改构造器、方法、属性的可见性 生成动态代理 反射的另外一个作用是运行时与注解配合，动态改变对象的行为。比如，为特定对象添加日志、权限控制等。 反射的实现基于4个类：Class、Construtor、Field和Method。 Class的对象用来描述运行是的类和接口，其是实现反射的基石，查看任何类都必须先获得一个Class对象。 获得Class对象的三种办法： MyClass.class MyClass是具体类名。JVM会使用ClassLoader类加载器将类加载到内存中，但并不会做任何类的初始化工作，返回java.lang.Class对象 Class.forName(&quot;类的全局定义名&quot;) 类全局名指包名+类名。类会被JVM加载到内存中，并且会进行类的静态初始化工作，返回java.lang.Class对象 new MyClass().getclass() 该方法使用了new进行实例化操作，因此静态初始化和非静态初始化工作都会进行，getClass方法属于顶级Object类中的方法，任何子类对象都可以调用，哪个子类调用，就返回那个子类的java.lang.Class对象 获得Class对象后，通过newInstance()实例化 newInstance()方法调用类的默认构造器生成对象 调用带参数构造器生成对象 Constructor con = class对象.getDeclaredConstructor(String.calss); con.setAccessible(true); Object obj = con.newInstance(“传入字符串”); Construtor类是构造方法描述类。 public Constructor[] getConstructors() 获得类中所有的public构造器数组，默认构造器下标为0 public Constructor getConstructor(Class...parameterTypes) 获得指定的public构造器，参数为构造器的参数类型（如要获得参数为String的构造器，则传入String.class） public Constructor[] getDeclaredConstructors() 获得类中所有构造器，包括私有的 public Constructor getDeclaredConstructor() 返回指定构造器区别在于getDeclaredXXX()只会获得该类自己声明的成员,包括私有的（通过void setAccessible(boolean flag)方法修改访问权限，false默认不可访问、true可访问），不会返回父类继承的。 Field是成员变量描述类。 public Field getDeclaredField(String name) 获得指定名字的成员变量 public Field[] getDeclaredFields() 获得所有成员变量 public Field getField(String name) public Field[] getFields()通过void set(Object obj,Object value)给obj对象的指定成员变量赋值 Method是封装方法的类。 public Method[] getDeclaredMethods() 获得所有方法 public Method getDeclaredMethod(String name,Class...parameterTypes) 获得指定方法 public Method[] getMethods() public Method getMethod(String name,Class...parameterTypes)通过Object invoke(Object obj,Object...args)调用obj对象的方法，传入参数为args","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[]},{"title":"Hexo命令","slug":"Hexo命令","date":"2020-01-30T10:34:43.000Z","updated":"2022-07-24T04:31:00.151Z","comments":true,"path":"2020/01/30/Hexo命令/","link":"","permalink":"http://yoursite.com/2020/01/30/Hexo命令/","excerpt":"","text":"Hexo使用过程中常用命令 nmp命令·npm install hexo -g ·npm update hexo -g init$hexo init [folder] 在文件夹folder下建立并初始化一个网站 new$hexo new [layout] &lt;title&gt;layout定义文章布局，有三个选项：post、page、draft ·默认post，存放所有博文内容·page对应网站菜单列表·draft保存未完成的草稿文章，默认不显示在页面中 server$hexo server在本地部署网站，默认预览地址为：http://localhost:4000/ generate$hexo generate生成静态文件 depoly$hexo depoly部署网站 clean$hexo clean 清除缓存","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[]},{"title":"操作系统引论","slug":"操作系统引论","date":"2019-09-18T01:34:29.000Z","updated":"2022-07-24T04:31:25.695Z","comments":true,"path":"2019/09/18/操作系统引论/","link":"","permalink":"http://yoursite.com/2019/09/18/操作系统引论/","excerpt":"","text":"操作系统引论 一、操作系统操作系统（Operating System）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理好这些设备，提高他们的利用率和系统吞吐量，并为用户和应用程序提供一个简单的接口。 1.1 操作系统的目标 * 主要目标：方便性（将机器语言转变为高级语言）、有效性（提高系统资源利用率和吞吐量）、可扩充性、开放性。 1.2 操作系统的作用 1.作为用户与计算机硬件系统之间的接口 2.作为计算机系统资源的管理者 * 处理机管理：分配和控制处理机； * 存储器管理：内存的分配和回收； * I/O设备管理：I/O设备的分配（回收）与操纵； * 文件管理：文件存取、共享和保护； * 用户接口管理：为用户提供命令、系统调用、图形等形式的接口管理。 3.实现对计算机资源的抽象 * I/O设备管理软件实现了对计算机硬件操作的第一层抽象； * 文件管理软件实现了对硬件资源操作的第二层抽象。 * 抽象层次越高，抽象接口提供的功能越强，用户使用越方便。二、操作系统发展过程2.5实时系统 1.特征：将时间作为关键参数，对所接收到的某些信号做出“及时”或“实时”的反应。 2.实时任务的类型 a.周期性实时任务和非周期实时任务。 * 其都必须联系着截止时间（Deadline）。 * 开始截止时间：某任务在某时间前必须开始执行。 * 完成截止时间：某时间前必须完成。 b.硬实时任务和软实时任务。 * 硬实时任务：系统必须满足任务对截止时间的要求。 * 软实时任务：系统也联系着截止时间，但并不严格，偶尔可错过截止时间。三、操作系统的基本特性3.1 并发 1.并行与并发 并行：两个或多个事件在同一时刻发生。 并发：两个或多个事件在同一时间间隔内发生。 2.引进进程 进程：能在系统中独立运行并作为资源分配的基本单位。多个进程之间可以并发执行和交换信息。 ps：进程和并发是现代操作系统最重要的基本概念。 3.2 共享 1.互斥共享 进程A访问某资源时，先提交申请，若资源空闲，则供A访问；若此后其他进程欲访问该资源，需等进程A访问完并释放系统资源。 临界资源：在一段时间内只允许一个进程访问的资源。 2.同时访问 “同时” 宏观上单处理机环境；微观上进程交替访问资源。 3.3 虚拟 虚拟：通过某种技术将一个物理实体变成若干个逻辑上的对应物的功能 1.时分复用技术 使设备得到最充分的利用。 2.空分复用技术 提高存储空间的利用率。 ps：设N是某物理设备对应的虚拟的逻辑设备数，采用时分复用，则每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N；采用空分复用，则每天虚拟设备的平均占用的空间必然等于或低于物理设备所拥有空间的1/N。 3.4 异步 进程的异步性：进程是以不可预知的速度向前推进的四、操作系统主要功能4.1 处理机管理 1.进程控制 * 功能：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。 2.进程同步 * 任务：为多个进程（含线程）的运行进行协调。 3.进程通信 * 任务：实现相互合作的进程之间的信息交换。 4.调度 a.作业调度。从后别队里按照一定的算法，选出若干作业，为他们分配运行所需的资源。 b.进程调度。从进程的就绪队列中按照一定算法选出一个线程，把处理机分配给他，并设置运行现场，使进程投入执行。 4.2 存储器管理 1.内存分配 * 任务：为每道程序分配内存。 2.内存保护 * 任务：确保每道用户程序都在自己的内存空间运行，彼此互不干扰。 3.地址映射 * 任务：将地址空间的逻辑地址转换为内存空间与之对应的物理地址。 4.内存扩充 任务：实现请求调入和置换功能。 4.3 设备管理功能 主要任务：完成用户提出的I/O请求，为用户分配I/O设备；提高CPU和I/O设备的利用率，提高I/O速度。 1.缓冲管理 2.设备分配 3.设备处理 4.4 文件管理功能 1.文件存储空间的管理 2.目录管理 3.文件的读写管理和保护五、OS结构设计5.4 微内核OS结构 1.基本概念 a.足够小的内核。内核指精心设计的、能实现现代OS最基本核心功能的小型内核。 b.基于客户/服务器模式。 c.应用“机制与策略分离”原理。机制指实现某一功能的具体执行机构。策略指在机制基础上借助于某些参数和算法来实现该功能的某些优化或达到不同的功能目标。 2.基本功能 a.进程（线程）管理 b.低级存储器管理 c.中断和陷入处理","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}],"keywords":[]},{"title":"Linux操作系统常用命令行","slug":"Linux常用命令","date":"2019-09-17T01:45:50.000Z","updated":"2020-09-02T12:08:16.823Z","comments":true,"path":"2019/09/17/Linux常用命令/","link":"","permalink":"http://yoursite.com/2019/09/17/Linux常用命令/","excerpt":"","text":"Linux操作系统常用命令行 目录 添加执行权限 创建与删除目录 磁盘操作 重启命令 关机命令 查看IP 切换用户 复制 查看目录下文件 删除文件 移动文件 输出命令 查看文件内容 查看当前所在目录 添加执行权限chmod 777 文件或目录（rwx分别代表数字421，rwxrwxrwx代表777即所有用户可读可写可执行）chmod u=rwx，g=rwx，o=rwx 文件名（user自己权限，group同群组用户权限，other其他用户权限，=设定，+添加，-去除） 创建与删除目录mkdir 目录名 (只能建一个目录)mkdir -p test1/test2/test3 (-p表示可以建多级目录)mkdir -m 777 test (-m表示建立目录时直接加上权限)rmdir 目录名 （删除一个空目录）rmdir -p 目录名 （-p连同上层空目录一起删除）rmdir -r 目录名 （-r目录下所有都删除） 磁盘操作fdisk -l （列出当前系统的磁盘情况）fdisk /dev/sdb （对sdb进行分区）mkfs.ext4 /dev/sdb || mkfs -t ext4 /dev/sdb1 （将/dev/sdb1格式化为ext4类型的系统）mount /dev/sdb1 /test （挂载分区操作，test需为空目录） 重启命令rebootshutdown -r now 立刻重启(root用户使用)shutdown -r 10 过10分钟自动重启(root用户使用)shutdown -r 10:10 在时间为10:10时候重启(root用户使用) 关机命令halt 立刻关机poweroff 立刻关机shutdown -h now 立刻关机(root用户使用)shutdown -h 10 10分钟后自动关机 查看IPifconfig 切换用户su 用户名sudo 切换超级用户 复制cp 源文件 目录cp -t 目录 源文件cp -p 源文件（-p连同复制文件的属性）cp -r 源文件（-r递归连续复制） 查看目录下文件ls -l 目录（显示档案的属性和权限）ls -a 目录（显示所有文档，包括隐藏的）ls -R 目录（显示目录下所有内容，包括子目录内容）ls -t 目录（显示按时间排序）ls -S 目录（显示按大小排序） 删除文件rm -r 源文件（递归删除）rm -f 源文件（强制删除）rm -i 源文件（互动删除，删除时询问） 移动文件mv 源文件 目录mv -t 目录 源文件mv 源文件 目的文件（修改文件名） 输出命令echo “输出内容”&gt;目的文件（echo “”&gt;test.txt可以建立一个空的text.txt文件） 查看文件内容cat（由第一行显示内容）cat -b （对非空白行列出行号）cat -n （连同空白行列出行号） tac （由最后一行显示内容） head （只看前几行）head -n 20 （显示前20行）head -n -20 （除了后20行全部显示） tail （只看后几行）tail -n 20（显示后20行） 查看当前所在目录pwd","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"Markdown语法","slug":"Markdown语法","date":"2019-09-16T00:59:48.000Z","updated":"2021-04-06T10:02:03.217Z","comments":true,"path":"2019/09/16/Markdown语法/","link":"","permalink":"http://yoursite.com/2019/09/16/Markdown语法/","excerpt":"","text":"测试和展示书写README的各种markdown语法。GitHub的markdown语法在标准的markdown语法基础上做了扩充，称之为GitHub Flavored Markdown。简称GFM，GFM在GitHub上有广泛应用，除了README文件外，issues和wiki均支持markdown语法。 目录 横线 标题 文本 普通文本 单行文本 多行文本 文字高亮 换行 斜体 粗体 删除线 图片 来源于网络的图片 GitHub仓库中的图片 链接 文字超链接 链接外部URL 链接本仓库里的URL 锚点 图片链接 列表 无序列表 有序列表 复选框列表 块引用 代码高亮 表格 表情 diff语法 横线 ***、—、___可以显示横线效果 标题一级标题二级标题三级标题四级标题五级标题六级标题文本普通文本这是一段普通的文本 单行文本Hello,大家好，我是果冻虾仁。在一行开头加入1个Tab或者4个空格。 文本块语法1在连续几行的文本开头加入1个Tab或者4个空格。 欢迎到访 很高兴见到您 祝您，早上好，中午好，下午好，晚安语法2使用一对各三个的反引号： 123欢迎到访我是C++码农你可以在知乎、CSDN、简书搜索【果冻虾仁】找到我 该语法也可以实现代码高亮，见代码高亮 文字高亮文字高亮功能能使行内部分文字高亮，使用一对反引号。语法： 1`linux` `网络编程` `socket` `epoll` 效果：linux 网络编程 socket epoll 也适合做一篇文章的tag 换行直接回车不能换行，可以在上一行文本后面补两个空格，这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 斜体、粗体、删除线 语法 效果 *斜体1* 斜体1 _斜体2_ 斜体2 **粗体1** 粗体1 __粗体2__ 粗体2 这是一个 ~~删除线~~ 这是一个 删除线 ***斜粗体1*** 斜粗体1 ___斜粗体2___ 斜粗体2 ***~~斜粗体删除线1~~*** 斜粗体删除线1 ~~***斜粗体删除线2***~~ 斜粗体删除线2 斜体、粗体、删除线可混合使用图片基本格式： 1![alt](URL title) alt和title即对应HTML中的alt和title属性（都可省略）： alt表示图片显示失败时的替换文本 title表示鼠标悬停在图片时的显示文本（注意这里要加引号） URL即图片的url地址，如果引用本仓库中的图片，直接使用相对路径就可了，如果引用其他github仓库中的图片要注意格式，即：仓库地址/raw/分支名/图片路径，如： 1https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif # 语法 效果 1 ![baidu](http://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;) 2 ![][foryou] ![][foryou] 注意例2的写法使用了URL标识符的形式，在链接一节有介绍。 在文末有foryou的定义： 1[foryou]:https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif 链接链接外部URL # 语法 效果 1 [我的博客](http://blog.csdn.net/guodongxiaren &quot;悬停显示&quot;) 我的博客 2 [我的知乎][zhihu] [我的知乎][zhihu] 语法2由两部分组成： 第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（姑且称之为URL标识符） 第二部分标记实际URL。 使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。 URL标识符是我起的名字，不知道是否准确。囧。。 链接本仓库里的URL 语法 效果 [我的简介](/example/profile.md) 我的简介 [example](./example) example 图片链接给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。 # 语法 效果 1 [![weibo-logo]](http://weibo.com/linpiaochen) ![weibo-logo] 2 [![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu] [][zhihu] 3 [![csdn-logo]][csdn] [![csdn-logo]][csdn] 因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。 本文URL标识符都放置于文末 锚点其实呢，每一个标题都是一个锚点，和HTML的锚点（#）类似，比如我们 语法 效果 [回到顶部](#readme) 回到顶部 不过要注意，标题中的英文字母都被转化为小写字母了。 以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！ 列表无序列表语法123* 昵称：果冻虾仁- 别名：隔壁老王* 英文名：Jelly 效果 昵称：果冻虾仁 别名：隔壁老王 英文名：Jelly 多级无序列表语法123* 编程语言 * 脚本语言 * Python 效果 编程语言 脚本语言 Python 一级有序列表语法就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。 12345面向对象的三个基本特征：1. 封装2. 继承3. 多态 效果面向对象的三个基本特征： 封装 继承 多态 多级有序列表和无序列表一样，有序列表也有多级结构。 语法1231. 这是一级的有序列表，数字1还是1 1. 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 1. 这是三级的有序列表，数字在显示的时候变成了英文字母 效果 这是一级的有序列表，数字1还是1 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字 这是三级的有序列表，数字在显示的时候变成了英文字母 复选框列表语法123456- [x] 需求分析- [x] 系统设计- [x] 详细设计- [ ] 编码- [ ] 测试- [ ] 交付 效果 需求分析 系统设计 详细设计 编码 测试 交付 您可以使用这个功能来标注某个项目各项任务的完成情况。 Tip: 在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。 块引用常用于引用文本文本摘自《深入理解计算机系统》P27 令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。 “端”（endian）的起源以下是Jonathan Swift在1726年关于大小端之争历史的描述：“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。” 块引用有多级结构语法12345&gt; 数据结构&gt;&gt; 树&gt;&gt;&gt; 二叉树&gt;&gt;&gt;&gt; 平衡二叉树&gt;&gt;&gt;&gt;&gt; 满二叉树 效果 数据结构 树 二叉树 平衡二叉树 满二叉树 代码高亮语法在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。 效果1public static void main(String[]args)&#123;&#125; //Java 1int main(int argc, char *argv[]) //C 1echo \"hello GitHub\" #Bash 1document.getElementById(\"myH1\").innerHTML=\"Welcome to my Homepage\"; //javascipt 1string &amp;operator+(const string&amp; A,const string&amp; B) //cpp 表格 表头1 表头2 表格单元 表格单元 表格单元 表格单元 表头1 表头2 表格单元 表格单元 表格单元 表格单元 对齐表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 混合其他语法表格单元中的内容可以和其他大多数GFM语法配合使用，如： 使用普通文本的删除线，斜体等效果 名字 描述 Help Display the help window. Close Closes a window 表格中嵌入图片（链接）其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。 图片 描述 ![baidu][baidu-logo] 百度 表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 比如:blush:，可以显示:blush:。 具体每一个表情的符号码，可以查询GitHub的官方网页http://www.emoji-cheat-sheet.com。 但是这个网页每次都打开奇慢。。所以我整理到了本repo中，大家可以直接在此查看emoji。 diff语法版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。 语法其语法与代码高亮类似，只是在三个反引号后面写diff，并且其内容中，以 +开头表示新增，-开头表示删除。 效果12+ 鸟宿池边树，僧敲月下门- 鸟宿池边树，僧推月下门 转载自果冻虾仁的github，原文出处:https://github.com/guodongxiaren/README","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}],"keywords":[]},{"title":"诗词","slug":"诗词","date":"2019-09-15T14:31:23.000Z","updated":"2019-09-18T01:02:17.166Z","comments":true,"path":"2019/09/15/诗词/","link":"","permalink":"http://yoursite.com/2019/09/15/诗词/","excerpt":"","text":"人间绝句近现代古诗词 且将新火试新茶，诗酒趁年华。《望江亭·超然台作》醉后不知天在水，满船清梦压星河。《题阳龙县青草湖》浮云一别后，流水十年间，欢笑情如旧，萧疏鬓已斑。《淮上喜会梁州故人》且挨过三冬四夏，暂受此些痛苦，雪后再看梅花。《百字铭》人本过客来无处，休说故里在何处。随遇而安无不可，人间到处有花香。《京华烟云》绿蚁新酿酒，红泥小火炉，晚来天欲酒，能饮一杯无。《问刘十九》","categories":[],"tags":[{"name":"文学","slug":"文学","permalink":"http://yoursite.com/tags/文学/"}],"keywords":[]}]}